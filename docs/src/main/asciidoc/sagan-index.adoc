Spring Cloud Contract is an umbrella project holding solutions that help users in successfully implementing the Consumer Driven Contracts approach. Currently Spring Cloud Contract consists of the Spring Cloud Contract Verifier project.

Spring Cloud Contract Verifier is a tool that enables Consumer Driven Contract (CDC) development of JVM-based applications. It is shipped with Contract Definition Language (DSL) written in Groovy or YAML. Contract definitions are used to produce following resources:

* by default JSON stub definitions to be used by WireMock (HTTP Server Stub) when doing integration testing on the client code (client tests). Test code must still be written by hand, test data is produced by Spring Cloud Contract Verifier.

* Messaging routes if you’re using one. We’re integrating with Spring Integration, Spring Cloud Stream and Apache Camel. You can however set your own integrations if you want to.

* Acceptance tests (by default in JUnit or Spock) used to verify if server-side implementation of the API is compliant with the contract (server tests). Full test is generated by Spring Cloud Contract Verifier.

Spring Cloud Contract Verifier moves TDD to the level of software architecture.

To see how Spring Cloud Contract supports other languages just check out https://spring.io/blog/2018/02/13/spring-cloud-contract-in-a-polyglot-world[this blog post].

## Features

When trying to test an application that communicates with other services then we could do one of two things:

* deploy all microservices and perform end to end tests

* mock other microservices in unit / integration tests

Both have their advantages but also a lot of disadvantages. Let’s focus on the latter.
Deploy all microservices and perform end to end tests

Advantages:

* simulates production

* tests real communication between services

Disadvantages:

* to test one microservice we would have to deploy 6 microservices, a couple of databases etc.

* the environment where the tests would be conducted would be locked for a single suite of tests (i.e. nobody else would be able to run the tests in the meantime).

* long to run

* very late feedback

* extremely hard to debug

Mock other microservices in unit / integration tests

Advantages:

* very fast feedback

* no infrastructure requirements

Disadvantages:

* the implementor of the service creates stubs thus they might have nothing to do with the reality

* you can go to production with passing tests and failing production

To solve the aforementioned issues Spring Cloud Contract Verifier with Stub Runner were created. Their main idea is to give you very fast feedback, without the need to set up the whole world of microservices.

Spring Cloud Contract Verifier features:

* ensure that HTTP / Messaging stubs (used when developing the client) are doing exactly what actual server-side implementation will do

* promote acceptance test driven development method and Microservices architectural style

* to provide a way to publish changes in contracts that are immediately visible on both sides of the communication

* to generate boilerplate test code used on the server side

