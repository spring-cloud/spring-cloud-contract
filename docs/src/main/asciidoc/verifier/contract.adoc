=== Contract DSL

IMPORTANT: Remember that inside the contract file you have to provide the fully qualified name to
the `Contract` class and the `make` static import i.e. `org.springframework.cloud.spec.Contract.make { ... }`.
You can also provide an import to the `Contract` class `import org.springframework.cloud.spec.Contract` and then call
  `Contract.make { ... }`

Contract DSL is written in Groovy, but don't be alarmed if you didn't use Groovy before. Knowledge of the language is not really needed as our DSL uses only
a tiny subset of it (namely literals, method calls and closures). What's more the DSL is designed to be programmer-readable without any knowledge of the DSL itself -
 it's statically typed.

TIP: Spring Cloud Contract supports defining multiple contracts in a single file!

The Contract is present in the `spring-cloud-contract-spec` module of the Spring Cloud Contract Verifier repository.

Let's look at full example of a contract definition.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderSpec.groovy[tags=dsl_example,indent=0]
----

Not all features of the DSL are used in example above. If you didn't find what you are looking for, please check next paragraphs on this page.

> You can easily compile Contracts to WireMock stubs mapping using standalone maven command: `mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert`.

==== Limitations

WARNING: Spring Cloud Contract Verifier doesn't support XML properly. Please use JSON or help us implement this feature.

WARNING: The support for the verification of size of JSON arrays is experimental. If you want to turn it on please provide
the value of a system property `spring.cloud.contract.verifier.assert.size` equal to `true`. By default this feature is set to
`false`. You can also provide the `assertJsonSize` property in the plugin configuration.

WARNING: Due to the fact that JSON structure can have any form it's sometimes impossible to parse it properly when using
the `value(consumer(...), producer(...))` notation when using that in GString. That's why we highly recommend using the
Groovy Map notation.

==== Common Top-Level elements

===== Description

You can add a `description` to your contract that is nothing else but an arbitrary text. Example:

[source,groovy,indent=0]
----
include::{contract_spec_path}/src/test/groovy/org/springframework/cloud/contract/spec/internal/ContractSpec.groovy[tags=description,indent=0]
----

===== Name

You can provide a name of your contract. Let's assume that you've provided a name `should register a user`.
If you do this then the name of the autogenerated test will be equal to `validate_should_register_a_user`.
Also the name of the stub will be `should_register_a_user.json` in case of a WireMock stub.

IMPORTANT: Please ensure that the name doesn't contain any characters that will make the generated test
 not possible to compile. Also remember that if you provide the same name for multiple contracts then your
 autogenerated tests will fail to compile and your generated stubs will override each other.

===== Ignoring contracts

If you want to ignore a contract you can either set a value of ignored contracts in the plugin configuration
or just set the `ignored` property on the contract itself:

[source,groovy,indent=0]
----
include::{contract_spec_path}/src/test/groovy/org/springframework/cloud/contract/spec/internal/ContractSpec.groovy[tags=ignored,indent=0]
----

==== HTTP Top-Level Elements

Following methods can be called in the top-level closure of a contract definition. Request and response are mandatory, priority is optional.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=http_dsl,indent=0]
----

==== Request

HTTP protocol requires only **method and address** to be specified in a request. The same information is mandatory in request definition of the Contract.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=request,indent=0]
----

It is possible to specify whole `url` instead of just path, but `urlPath` is the recommended way as it makes the tests **host-independent**.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=url,indent=0]

----

Request may contain **query parameters**, which are specified in a closure nested in a call to `urlPath` or `url`.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=urlpath,indent=0]
----

It may contain additional **request headers**...

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=headers,indent=0]
----

...and a **request body**.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=body,indent=0]
----

//**Body's format** can also be specified explicitly by invoking one of format functions.
//
//[source,groovy,indent=0]
//----
//include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=bodyAsXml,indent=0]
//----

==== Response

Minimal response must contain **HTTP status code**.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=response,indent=0]
----

Besides status response may contain **headers** and **body**, which are specified the same way as in the request (see previous paragraph).

==== Dynamic properties

The contract can contain some dynamic properties - timestamps / ids etc. You don't want to enforce the consumers to stub their
clocks to always return the same value of time so that it gets matched by the stub. That's why we allow you to provide the dynamic
parts in your contracts in the following way

either via the `value` method

[source,groovy,indent=0]
----
value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))
----

or if you're using the Groovy map notation for body you can use the `$()` method

[source,groovy,indent=0]
----
$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))
----

All of the aforementioned approaches are equal. That means that `stub` and `client` methods are aliases over the `consumer`
method. Let's take a closer look at what we can do with those values in the subsequent sections.

==== Regular expressions

You can use regular expressions to write your requests in Contract DSL. It is particularly useful when you want to indicate that a given response
should be provided for requests that follow a given pattern. Also, you can use it when you need to use patterns and not exact values both
for your test and your server side tests.

Please see the example below:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=regex,indent=0]
----

You can also provide only one side of the communication using a regular expression. If you do that then automatically we'll
provide the generated string that matches the provided regular expression. For example:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderSpec.groovy[tags=dsl_one_side_data_generation_example,indent=0]
----

In this example for request and response the opposite side of the communication will have the respective data generated.

Spring Cloud Contract comes with a series of predefined regular expressions that you can use in your contracts.

[source,groovy,indent=0]
----
include::{contract_spec_path}/src/main/groovy/org/springframework/cloud/contract/spec/internal/RegexPatterns.groovy[tags=regexps,indent=0]
----

so in your contract you can use it like this

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderSpec.groovy[tags=contract_with_regex,indent=0]
----


==== Passing optional parameters

It is possible to provide optional parameters in your contract. It's only possible to have optional parameter for the:

- __STUB__ side of the Request
- __TEST__ side of the Response

Example:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=optionals,indent=0]
----

By wrapping a part of the body with the `optional()` method you are in fact creating a regular expression that should be present 0 or more times.

That way for the example above the following test would be generated if you pick Spock:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=optionals_test,indent=0]
----

and the following stub:

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-converters/src/test/groovy/org/springframework/cloud/contract/verifier/wiremock/DslToWireMockClientConverterSpec.groovy[tags=wiremock,indent=0]
----

==== Executing custom methods on server side

It is also possible to define a method call to be executed on the server side during the test. Such a method can be added to the class defined as "baseClassForTests"
in the configuration. Please see the examples below:

===== Contract DSL

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=method,indent=0]
----

===== Base Mock Spec

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-gradle-plugin/src/test/resources/functionalTest/bootSimple/src/test/groovy/org/springframework/cloud/contract/verifier/twitter/places/BaseMockMvcSpec.groovy[tags=base_class,indent=0]
----

==== JAX-RS support

We support JAX-RS 2 Client API. Base class needs to define `protected WebTarget webTarget` and server initialization, right now the only option how to test JAX-RS API is to start a web server.

Request with a body needs to have a content type set otherwise `application/octet-stream` is going to be used.

In order to use JAX-RS mode, use the following settings:

[source,groovy,indent=0]
----
testMode === 'JAXRSCLIENT'
----

Example of a test API generated:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/JaxRsClientMethodBuilderSpec.groovy[tags=jaxrs,indent=0]
----

==== Async support

If you're using asynchronous communication on the server side (your controllers are returning
`Callable`, `DeferredResult` etc. then inside your contract you have to provide in the `response`
section a `async()` method. Example:

[source,groovy,indent=0]
----
org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status 200
        body 'Passed'
        async()
    }
}
----


==== Messaging Top-Level Elements

The DSL for messaging looks a little bit different than the one that focuses on HTTP.

===== Output triggered by a method

The output message can be triggered by calling a method (e.g. a Scheduler was started and a message was sent)

[source,groovy]
----
include::{tests_path}/samples-messaging-integration/src/test/groovy/com/example/IntegrationMessagingApplicationSpec.groovy[tags=method_trigger,indent=0]
----

In this case the output message will be sent to `output` if a method called `bookReturnedTriggered` will be executed. In the message *publisher's* side
we will generate a test that will call that method to trigger the message. On the *consumer* side you can use the `some_label` to trigger the message.

===== Output triggered by a message

The output message can be triggered by receiving a message.

[source,groovy]
----
include::{tests_path}/samples-messaging-integration/src/test/groovy/com/example/IntegrationMessagingApplicationSpec.groovy[tags=message_trigger,indent=0]
----

In this case the output message will be sent to `output` if a proper message will be received on the `input` destination. In the message *publisher's* side
we will generate a test that will send the input message to the defined destination. On the *consumer* side you can either send a message to the input
destination or use the `some_label` to trigger the message.

===== Consumer / Producer

In HTTP you have a notion of `client`/`stub and `server`/`test` notation. You can use them also in messaging but we're providing also the `consumer` and `produer` methods
as presented below (note you can use either `$` or `value` methods to provide `consumer` and `producer` parts)

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=consumer_producer]
----

==== Multiple contracts in one file

It's possible to define multiple contracts in one file. An example of such a contract can look like this

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-maven-plugin/src/test/projects/multiple-contracts/src/test/resources/contracts/com/hello/v1/WithList.groovy[lines=18..-1,indent=0]
----

In this example one contract has the `name` field and the other doesn't. This will lead to generation of
two tests that will look more or less like this:

[source,java,indent=0]
----
package org.springframework.cloud.contract.verifier.tests.com.hello;

import com.example.TestBase;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
import com.jayway.restassured.response.ResponseOptions;
import org.junit.Test;

import static com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.assertj.core.api.Assertions.assertThat;

public class V1Test extends TestBase {

	@Test
	public void validate_should_post_a_user() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/1");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

	@Test
	public void validate_withList_1() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/2");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

}
----

Notice that for the contract that has the `name` field the generated test method is named
`validate_should_post_a_user`. For the one that doesn't have the name it's called
`validate_withList_1`. It corresponds to the name of the file `WithList.groovy` and the
index of the contract in the list.

The generated stubs will look like this

[source]
----
should post a user.json
1_WithList.json
----

As you can see the first file got the `name` parameter from the contract. The second
got the name of the contract file `WithList.groovy` prefixed with the index (in this case
contract had index `1` in the list of contracts in the file).

TIP: As you can see it's much better if you name your contracts since then your tests
 are far more meaningful.


=== Customization

==== Extending the DSL

It is possible to provide your own functions to the DSL. The key requirement for this
feature was to maintain the static compatibility. Below you will be able to see an example
of:

- creation of a JAR with reusable classes
- referencing of these classes in the DSLs

The full example can be found https://github.com/spring-cloud-samples/spring-cloud-contract-samples[here].

===== Common JAR

Below you can find three classes that we will reuse in the DSLs.

*PatternUtils* contains functions used by both the **consumer** and the **producer**.

[source,java]
----
include::{samples_url}/common/src/main/java/com/example/PatternUtils.java[]
----

*ConsumerUtils* contains functions used by the **consumer**.

[source,java]
----
include::{samples_url}/common/src/main/java/com/example/ConsumerUtils.java[]
----

*ProducerUtils* contains functions used by the **producer**.

[source,java]
----
include::{samples_url}/common/src/main/java/com/example/ProducerUtils.java[]
----

===== Adding the dependency to project

In order for the plugins and IDE to be able to reference the common JAR classes you need
to pass the dependency to your project.

====== Test dependency in project's dependencies

First add the common jar dependency as a test dependency. That way since your
contracts files are available at test resources path, automatically the
common jar classes will be visible in your Groovy files.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{samples_url}/producer/pom.xml[tags=test_dep,indent=0]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{samples_url}/producer/build.gradle[tags=test_dep,indent=0]
----

====== Test dependency in plugin's dependencies

Now you have to add the dependency for the plugin to reuse at runtime.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{samples_url}/producer/pom.xml[tags=test_dep_in_plugin,indent=0]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{samples_url}/producer/build.gradle[tags=test_dep_in_plugin,indent=0]
----

====== Referencing classes in DSLs

Now you can reference your classes in your DSL. Example:

[source,groovy]
----
include::{samples_url}/producer/src/test/resources/contracts/beer/rest/shouldGrantABeerIfOldEnough.groovy[indent=0]
----

=== Pluggable architecture

There are cases where you have your contracts defined in other formats
like YAML, RAML or PACT. On the other hand you'd like to profit from
the test and stubs generation. It's really easy to add your own implementation
of either of those. Also you can customize the way tests are generated (for example you can generate
tests for other languages) and you can do the same for stubs generation (you can generate
stubs for other stub http server implementations).

==== Custom contract converter

Let's assume that your contract is written in a YAML file like this:

[source,yml]
----
include::{verifier_core_path}/src/test/resources/contract.yml[indent=0]
----

Thanks to the interface

[source,groovy]
----
include::{contract_spec_path}/src/main/groovy/org/springframework/cloud/contract/spec/ContractConverter.groovy[indent=0,lines=17..-1]
----

you can register your own implementation of a contract structure converter.
Your implementation needs to state the condition on which it should start the
conversion. Also you have to define how to perform that conversion in both ways.

IMPORTANT: Once you create your implementation you have to create a `/META-INF/spring.factories`
file in which you provide the fully qualified name of your implementation.

Example of a `spring.factories` file

[source]
----
include::{verifier_core_path}/src/test/resources/META-INF/spring.factories[indent=0]
----

and the YAML implementation

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/converter/YamlContractConverter.groovy[indent=0,lines=16..-1]
----

==== Custom test generator

If you want to generate tests for different languages than Java or you're
not happy with the way we're building Java tests for you then you can register
your own implementation to do that.

Thanks to the interface

[source,groovy]
----
include::{verifier_core_path}/src/main/groovy/org/springframework/cloud/contract/verifier/builder/SingleTestGenerator.groovy[indent=0,lines=17..-1]
----

you can register your own implementation that generates a test. Again, it's enough to provide
a proper `spring.factories` file. Example:

[source]
----
org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator
----

==== Custom stub generator

If you want to generate stubs for other stub server than WireMock it's enough to
 plug in your own implementation of this interface:

[source,groovy]
----
include::{converters_path}/src/main/groovy/org/springframework/cloud/contract/verifier/converter/StubGenerator.groovy[indent=0,lines=16..-1]
----

you can register your own implementation that generate Stubs. Again, it's enough to provide
a proper `spring.factories` file. Example:

[source]
----
include::{converters_path}/src/main/resources/META-INF/spring.factories[indent=0]
----

The default implementation is the WireMock stub generation.

==== Custom Stub Runner

If you decide to have a custom stub generation you also need a custom way of running
stubs with your different stub provider.

Let us assume that you're using https://github.com/dreamhead/moco[Moco] to build your stubs.
You wrote a proper stub generator and your stubs got placed in a JAR file.

In order for Stub Runner to know how to run your stubs you have to define a custom
 HTTP Stub server implementation. It can look like this:

[source,groovy]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/groovy/org/springframework/cloud/contract/stubrunner/provider/moco/MocoHttpServerStub.groovy[indent=0]
----

and just register it in your `spring.factories` file

[source]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/resources/META-INF/spring.factories[indent=0,lines=1,4]
----

that way you'll be able to run stubs using Moco.

IMPORTANT: If you don't provide any implementation then the default one - WireMock based
will be picked. If you provide more than one then the first one on the list will be picked.

==== Custom Stub Downloader

You can customize the way your stubs are downloaded. If you don't want to download the JARs
from Nexus / Artifactory in the way we do by default you can set your own implementation.
Below you can find an example of a Stub Downloader Provider that takes `json` files from the test resources
from classpath, copies them to a temp file and then passes that temporary folder
 as a root for the stubs.

[source,java]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/groovy/org/springframework/cloud/contract/stubrunner/provider/moco/ClasspathStubProvider.java[indent=0]
----

and just register it in your `spring.factories` file

[source]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/resources/META-INF/spring.factories[indent=0,lines=5..-1]
----

that way you'll be able to pick a folder with the source of your stubs.

IMPORTANT: If you don't provide any implementation then the default one - Aether based that will download stubs from a remote repo
will be picked. If you provide more than one then the first one on the list will be picked.
