=== Contract DSL

IMPORTANT: Remember that inside the contract file you have to provide the fully qualified name to
the `Contract` class and the `make` static import i.e. `org.springframework.cloud.spec.Contract.make { ... }`.
You can also provide an import to the `Contract` class `import org.springframework.cloud.spec.Contract` and then call
  `Contract.make { ... }`

Contract DSL is written in Groovy, but don't be alarmed if you didn't use Groovy before. Knowledge of the language is not really needed as our DSL uses only
a tiny subset of it (namely literals, method calls and closures). What's more the DSL is designed to be programmer-readable without any knowledge of the DSL itself -
 it's statically typed.

TIP: Spring Cloud Contract supports defining multiple contracts in a single file!

The Contract is present in the `spring-cloud-contract-spec` module of the Spring Cloud Contract Verifier repository.

Let's look at full example of a contract definition.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderSpec.groovy[tags=dsl_example,indent=0]
----

Not all features of the DSL are used in example above. If you didn't find what you are looking for, please check next paragraphs on this page.

> You can easily compile Contracts to WireMock stubs mapping using standalone maven command: `mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert`.

==== Limitations

WARNING: Spring Cloud Contract Verifier doesn't support XML properly. Please use JSON or help us implement this feature.

WARNING: The support for the verification of size of JSON arrays is experimental. If you want to turn it on please provide
the value of a system property `spring.cloud.contract.verifier.assert.size` equal to `true`. By default this feature is set to
`false`. You can also provide the `assertJsonSize` property in the plugin configuration.

WARNING: Due to the fact that JSON structure can have any form it's sometimes impossible to parse it properly when using
the `value(consumer(...), producer(...))` notation when using that in GString. That's why we highly recommend using the
Groovy Map notation.

==== Common Top-Level elements

===== Description

You can add a `description` to your contract that is nothing else but an arbitrary text. Example:

[source,groovy,indent=0]
----
include::{contract_spec_path}/src/test/groovy/org/springframework/cloud/contract/spec/internal/ContractSpec.groovy[tags=description,indent=0]
----

===== Name

You can provide a name of your contract. Let's assume that you've provided a name `should register a user`.
If you do this then the name of the autogenerated test will be equal to `validate_should_register_a_user`.
Also the name of the stub will be `should_register_a_user.json` in case of a WireMock stub.

IMPORTANT: Please ensure that the name doesn't contain any characters that will make the generated test
 not possible to compile. Also remember that if you provide the same name for multiple contracts then your
 autogenerated tests will fail to compile and your generated stubs will override each other.

===== Ignoring contracts

If you want to ignore a contract you can either set a value of ignored contracts in the plugin configuration
or just set the `ignored` property on the contract itself:

[source,groovy,indent=0]
----
include::{contract_spec_path}/src/test/groovy/org/springframework/cloud/contract/spec/internal/ContractSpec.groovy[tags=ignored,indent=0]
----

==== HTTP Top-Level Elements

Following methods can be called in the top-level closure of a contract definition. Request and response are mandatory, priority is optional.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=http_dsl,indent=0]
----

==== Request

HTTP protocol requires only **method and address** to be specified in a request. The same information is mandatory in request definition of the Contract.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=request,indent=0]
----

It is possible to specify whole `url` instead of just path, but `urlPath` is the recommended way as it makes the tests **host-independent**.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=url,indent=0]

----

Request may contain **query parameters**, which are specified in a closure nested in a call to `urlPath` or `url`.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=urlpath,indent=0]
----

It may contain additional **request headers**...

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=headers,indent=0]
----

...and a **request body**.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=body,indent=0]
----

//**Body's format** can also be specified explicitly by invoking one of format functions.
//
//[source,groovy,indent=0]
//----
//include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=bodyAsXml,indent=0]
//----

==== Response

Minimal response must contain **HTTP status code**.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=response,indent=0]
----

Besides status response may contain **headers** and **body**, which are specified the same way as in the request (see previous paragraph).

==== Dynamic properties

The contract can contain some dynamic properties - timestamps / ids etc. You don't want to enforce the consumers to stub their
clocks to always return the same value of time so that it gets matched by the stub. That's why we allow you to provide the dynamic
parts in your contracts in two ways. One is to pass them directly in the
body and one to set them in a separate section called `testMatchers` and `stubMatchers`.

===== Dynamic properties inside the body

You can set the properties inside the body either via the `value` method

[source,groovy,indent=0]
----
value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))
----

or if you're using the Groovy map notation for body you can use the `$()` method

[source,groovy,indent=0]
----
$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))
----

All of the aforementioned approaches are equal. That means that `stub` and `client` methods are aliases over the `consumer`
method. Let's take a closer look at what we can do with those values in the subsequent sections.

====== Regular expressions

You can use regular expressions to write your requests in Contract DSL. It is particularly useful when you want to indicate that a given response
should be provided for requests that follow a given pattern. Also, you can use it when you need to use patterns and not exact values both
for your test and your server side tests.

Please see the example below:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=regex,indent=0]
----

You can also provide only one side of the communication using a regular expression. If you do that then automatically we'll
provide the generated string that matches the provided regular expression. For example:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderSpec.groovy[tags=dsl_one_side_data_generation_example,indent=0]
----

In this example for request and response the opposite side of the communication will have the respective data generated.

Spring Cloud Contract comes with a series of predefined regular expressions that you can use in your contracts.

[source,groovy,indent=0]
----
include::{contract_spec_path}/src/main/groovy/org/springframework/cloud/contract/spec/internal/RegexPatterns.groovy[tags=regexps,indent=0]
----

so in your contract you can use it like this

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderSpec.groovy[tags=contract_with_regex,indent=0]
----

====== Passing optional parameters

It is possible to provide optional parameters in your contract. It's only possible to have optional parameter for the:

- __STUB__ side of the Request
- __TEST__ side of the Response

Example:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=optionals,indent=0]
----

By wrapping a part of the body with the `optional()` method you are in fact creating a regular expression that should be present 0 or more times.

That way for the example above the following test would be generated if you pick Spock:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=optionals_test,indent=0]
----

and the following stub:

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-converters/src/test/groovy/org/springframework/cloud/contract/verifier/wiremock/DslToWireMockClientConverterSpec.groovy[tags=wiremock,indent=0]
----

====== Executing custom methods on server side

It is also possible to define a method call to be executed on the server side during the test. Such a method can be added to the class defined as "baseClassForTests"
in the configuration. Example:

*Contract*

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/ContractHttpDocsSpec.groovy[tags=method,indent=0]
----

*Base class*

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-gradle-plugin/src/test/resources/functionalTest/bootSimple/src/test/groovy/org/springframework/cloud/contract/verifier/twitter/places/BaseMockMvcSpec.groovy[tags=base_class,indent=0]
----

===== Dynamic properties in matchers sections

If you've been working with https://docs.pact.io/[Pact] this might seem familiar. Quite a few users
are used to having a separation between the body and setting dynamic parts of your contract.

That's why you can profit from two separate sections. One is called `stubMatchers` where you can
define the dynamic values that should end up in a stub. You can set it in the `request` or `inputMessage`
part of your contract. The other is called `testMatchers` which is present in the `response` or
`outputMessage` side of the contract.

Currently we support only JSON Path based matchers with the following matching possibilities.
For `stubMatchers`:

- `byEquality()` - the value taken from the response via the provided JSON Path needs
to be equal to the provided value in the contract
- `byRegex(...)` - the value taken from the response via the provided JSON Path needs
to match the regex
- `byDate()` - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Date
- `byTimestamp()` - the value taken from the response via the provided JSON Path needs
to match the regex for ISO DateTime
- `byTime()` - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Time

For `testMatchers`:

- `byEquality()` - the value taken from the response via the provided JSON Path needs
to be equal to the provided value in the contract
- `byRegex(...)` - the value taken from the response via the provided JSON Path needs
to match the regex
- `byDate()` - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Date
- `byTimestamp()` - the value taken from the response via the provided JSON Path needs
to match the regex for ISO DateTime
- `byTime()` - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Time
- `byType()` - the value taken from the response via the provided JSON Path needs to
be of the same type as the type defined in the body of the response in the contract.
`byType` can take a closure where you can set `minOccurrence` and `maxOccurrence`.
That way you can assert on the size of the collection.
- `byCommand(...)` - the value taken from the response via the provided JSON Path will be
passed as an input to the custom method that you're providing. E.g. `byCommand('foo($it)')`
will result in calling a `foo` method to which the value matching the JSON Path will get
 passed.

Let's take a look at the following example:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MockMvcMethodBodyBuilderWithMatchersSpec.groovy[tags=matchers,indent=0]
----

In this example we're providing the dynamic portions of the contract in the matchers sections.
 For the request part you can see that for all fields but `valueWithoutAMatcher` we're setting
 explicitly the values of regular expressions we'd like the stub to contain. For the `valueWithoutAMatcher`
 the verification will take place in the same way as without the usage of matchers - the test
 will perform an equality check in this case.

For the response side in the `testMatchers` section we're defining all the dynamic parts
 in a similar manner. The only difference is that we have the `byType` matchers too. In that
 case we're checking 4 fields in the way that we're verifying whether the response from the test
 has a value whose JSON path matching the given field is of the same type as the one defined in the response body and:

 - for `$.valueWithTypeMatch` - we're just checking the whether the type is the same
 - for `$.valueWithMin` - we're checking the type and assert if the size is greater or equal to the min occurrence
 - for `$.valueWithMax` - we're checking the type and assert if the size is smaller or equal to the max occurrence
 - for `$.valueWithMinMax` - we're checking the type and assert if the size is between the min and max occurrence

The resulting test would look more or less like this (note that we're separating the autogenerated
assertions and the one from matchers with an `and` section):

[source,java,indent=0]
----
 // given:
  MockMvcRequestSpecification request = given()
    .header("Content-Type", "application/json")
    .body("{\"duck\":123,\"alpha\":\"abc\",\"number\":123,\"aBoolean\":true,\"date\":\"2017-01-01\",\"dateTime\":\"2017-01-01T01:23:45\",\"time\":\"01:02:34\",\"valueWithoutAMatcher\":\"foo\",\"valueWithTypeMatch\":\"string\"}");

 // when:
  ResponseOptions response = given().spec(request)
    .get("/get");

 // then:
  assertThat(response.statusCode()).isEqualTo(200);
  assertThat(response.header("Content-Type")).matches("application/json.*");
 // and:
  DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
  assertThatJson(parsedJson).field("valueWithoutAMatcher").isEqualTo("foo");
 // and:
  assertThat(parsedJson.read("$.duck", String.class)).matches("[0-9]{3}");
  assertThat(parsedJson.read("$.duck", Integer.class)).isEqualTo(123);
  assertThat(parsedJson.read("$.alpha", String.class)).matches("[\\p{L}]*");
  assertThat(parsedJson.read("$.alpha", String.class)).isEqualTo("abc");
  assertThat(parsedJson.read("$.number", String.class)).matches("-?\\d*(\\.\\d+)?");
  assertThat(parsedJson.read("$.aBoolean", String.class)).matches("(true|false)");
  assertThat(parsedJson.read("$.date", String.class)).matches("(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])");
  assertThat(parsedJson.read("$.dateTime", String.class)).matches("([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
  assertThat(parsedJson.read("$.time", String.class)).matches("(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
  assertThat((Object) parsedJson.read("$.valueWithTypeMatch")).isInstanceOf(java.lang.String.class);
  assertThat((Object) parsedJson.read("$.valueWithMin")).isInstanceOf(java.util.List.class);
  assertThat(parsedJson.read("$.valueWithMin", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(1);
  assertThat((Object) parsedJson.read("$.valueWithMax")).isInstanceOf(java.util.List.class);
  assertThat(parsedJson.read("$.valueWithMax", java.util.Collection.class)).hasSizeLessThanOrEqualTo(3);
  assertThat((Object) parsedJson.read("$.valueWithMinMax")).isInstanceOf(java.util.List.class);
  assertThat(parsedJson.read("$.valueWithMinMax", java.util.Collection.class)).hasSizeBetween(1, 3);
  assertThat((Object) parsedJson.read("$.valueWithMinEmpty")).isInstanceOf(java.util.List.class);
  assertThat(parsedJson.read("$.valueWithMinEmpty", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(0);
  assertThat((Object) parsedJson.read("$.valueWithMaxEmpty")).isInstanceOf(java.util.List.class);
  assertThat(parsedJson.read("$.valueWithMaxEmpty", java.util.Collection.class)).hasSizeLessThanOrEqualTo(0);
  assertThatValueIsANumber(parsedJson.read("$.duck"));
----

and the WireMock stub like this:

[source,json,indent=0]
----
include::{plugins_path}/spring-cloud-contract-converters/src/test/groovy/org/springframework/cloud/contract/verifier/wiremock/DslToWireMockClientConverterSpec.groovy[tags=matchers,indent=0]
----

==== JAX-RS support

We support JAX-RS 2 Client API. Base class needs to define `protected WebTarget webTarget` and server initialization, right now the only option how to test JAX-RS API is to start a web server.

Request with a body needs to have a content type set otherwise `application/octet-stream` is going to be used.

In order to use JAX-RS mode, use the following settings:

[source,groovy,indent=0]
----
testMode === 'JAXRSCLIENT'
----

Example of a test API generated:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/JaxRsClientMethodBuilderSpec.groovy[tags=jaxrs,indent=0]
----

==== Async support

If you're using asynchronous communication on the server side (your controllers are returning
`Callable`, `DeferredResult` etc. then inside your contract you have to provide in the `response`
section a `async()` method. Example:

[source,groovy,indent=0]
----
org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status 200
        body 'Passed'
        async()
    }
}
----

==== Working with Context Paths

Spring Cloud Contract supports context paths.

IMPORTANT: The only thing that changes in order to fully support context paths is the switch
on the *PRODUCER* side. The autogenerated tests need to be using the *EXPLICIT* mode.

The consumer side remains untouched, in order for the generated test to pass you have to switch the *EXPLICIT* mode.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <testMode>EXPLICIT</testMode>
    </configuration>
</plugin>
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
contracts {
		testMode = 'EXPLICIT'
}
----

That way you'll generate a test that *DOES NOT* use MockMvc. It means that you're generating
real requests and you need to setup your generated test's base class to work on a real socket.

Let's imagine the following contract:

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/SingleTestGeneratorSpec.groovy[tags=context_path_contract,indent=0]
----

Here is an example of how to set up a base class and Rest Assured for everything to work correctly.

[source,groovy,indent=0]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/SingleTestGeneratorSpec.groovy[tags=context_path_baseclass,indent=0]
----

That way all:

- all your requests in the autogenerated tests will be sent to the real endpoint with your context path included (e.g. `/my-context-path/url`)
- your contracts reflect that you have a context path, thus your generated stubs will also
 have that information (e.g. in the stubs you'll see that you have too call `/my-context-path/url`)

==== Messaging Top-Level Elements

The DSL for messaging looks a little bit different than the one that focuses on HTTP.

===== Output triggered by a method

The output message can be triggered by calling a method (e.g. a Scheduler was started and a message was sent)

[source,groovy]
----
include::{tests_path}/samples-messaging-integration/src/test/groovy/com/example/IntegrationMessagingApplicationSpec.groovy[tags=method_trigger,indent=0]
----

In this case the output message will be sent to `output` if a method called `bookReturnedTriggered` will be executed. In the message *publisher's* side
we will generate a test that will call that method to trigger the message. On the *consumer* side you can use the `some_label` to trigger the message.

===== Output triggered by a message

The output message can be triggered by receiving a message.

[source,groovy]
----
include::{tests_path}/samples-messaging-integration/src/test/groovy/com/example/IntegrationMessagingApplicationSpec.groovy[tags=message_trigger,indent=0]
----

In this case the output message will be sent to `output` if a proper message will be received on the `input` destination. In the message *publisher's* side
we will generate a test that will send the input message to the defined destination. On the *consumer* side you can either send a message to the input
destination or use the `some_label` to trigger the message.

===== Consumer / Producer

In HTTP you have a notion of `client`/`stub and `server`/`test` notation. You can use them also in messaging but we're providing also the `consumer` and `produer` methods
as presented below (note you can use either `$` or `value` methods to provide `consumer` and `producer` parts)

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=consumer_producer]
----

==== Multiple contracts in one file

It's possible to define multiple contracts in one file. An example of such a contract can look like this

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-maven-plugin/src/test/projects/multiple-contracts/src/test/resources/contracts/com/hello/v1/WithList.groovy[lines=18..-1,indent=0]
----

In this example one contract has the `name` field and the other doesn't. This will lead to generation of
two tests that will look more or less like this:

[source,java,indent=0]
----
package org.springframework.cloud.contract.verifier.tests.com.hello;

import com.example.TestBase;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
import com.jayway.restassured.response.ResponseOptions;
import org.junit.Test;

import static com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.assertj.core.api.Assertions.assertThat;

public class V1Test extends TestBase {

	@Test
	public void validate_should_post_a_user() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/1");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

	@Test
	public void validate_withList_1() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/2");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

}
----

Notice that for the contract that has the `name` field the generated test method is named
`validate_should_post_a_user`. For the one that doesn't have the name it's called
`validate_withList_1`. It corresponds to the name of the file `WithList.groovy` and the
index of the contract in the list.

The generated stubs will look like this

[source]
----
should post a user.json
1_WithList.json
----

As you can see the first file got the `name` parameter from the contract. The second
got the name of the contract file `WithList.groovy` prefixed with the index (in this case
contract had index `1` in the list of contracts in the file).

TIP: As you can see it's much better if you name your contracts since then your tests
 are far more meaningful.


=== Customization

==== Extending the DSL

It is possible to provide your own functions to the DSL. The key requirement for this
feature was to maintain the static compatibility. Below you will be able to see an example
of:

- creation of a JAR with reusable classes
- referencing of these classes in the DSLs

The full example can be found https://github.com/spring-cloud-samples/spring-cloud-contract-samples[here].

===== Common JAR

Below you can find three classes that we will reuse in the DSLs.

*PatternUtils* contains functions used by both the **consumer** and the **producer**.

[source,java]
----
include::{samples_url}/common/src/main/java/com/example/PatternUtils.java[]
----

*ConsumerUtils* contains functions used by the **consumer**.

[source,java]
----
include::{samples_url}/common/src/main/java/com/example/ConsumerUtils.java[]
----

*ProducerUtils* contains functions used by the **producer**.

[source,java]
----
include::{samples_url}/common/src/main/java/com/example/ProducerUtils.java[]
----

===== Adding the dependency to project

In order for the plugins and IDE to be able to reference the common JAR classes you need
to pass the dependency to your project.

====== Test dependency in project's dependencies

First add the common jar dependency as a test dependency. That way since your
contracts files are available at test resources path, automatically the
common jar classes will be visible in your Groovy files.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{samples_url}/producer/pom.xml[tags=test_dep,indent=0]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{samples_url}/producer/build.gradle[tags=test_dep,indent=0]
----

====== Test dependency in plugin's dependencies

Now you have to add the dependency for the plugin to reuse at runtime.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{samples_url}/producer/pom.xml[tags=test_dep_in_plugin,indent=0]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{samples_url}/producer/build.gradle[tags=test_dep_in_plugin,indent=0]
----

====== Referencing classes in DSLs

Now you can reference your classes in your DSL. Example:

[source,groovy]
----
include::{samples_url}/producer/src/test/resources/contracts/beer/rest/shouldGrantABeerIfOldEnough.groovy[indent=0]
----

=== Pluggable architecture

There are cases where you have your contracts defined in other formats
like YAML, RAML or PACT. On the other hand you'd like to profit from
the test and stubs generation. It's really easy to add your own implementation
of either of those. Also you can customize the way tests are generated (for example you can generate
tests for other languages) and you can do the same for stubs generation (you can generate
stubs for other stub http server implementations).

==== Custom contract converter

Let's assume that your contract is written in a YAML file like this:

[source,yml]
----
include::{verifier_core_path}/src/test/resources/contract.yml[indent=0]
----

Thanks to the interface

[source,groovy]
----
include::{contract_spec_path}/src/main/groovy/org/springframework/cloud/contract/spec/ContractConverter.groovy[indent=0,lines=17..-1]
----

you can register your own implementation of a contract structure converter.
Your implementation needs to state the condition on which it should start the
conversion. Also you have to define how to perform that conversion in both ways.

IMPORTANT: Once you create your implementation you have to create a `/META-INF/spring.factories`
file in which you provide the fully qualified name of your implementation.

Example of a `spring.factories` file

[source]
----
include::{verifier_core_path}/src/test/resources/META-INF/spring.factories[indent=0]
----

and the YAML implementation

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/converter/YamlContractConverter.groovy[indent=0,lines=16..-1]
----

===== Pact converter

Spring Cloud Contract comes with an out of the box support for https://docs.pact.io/[Pact] representation of contracts.
In other words instead of using the Groovy DSL you can use Pact files. In this section
we will present how to add such a support for your project.

====== Pact contract

We will be working on the following example of a Pact contract. We've placed this file under
the `src/test/resources/contracts` folder.

[source,javascript,indent=0]
----
include::{standalone_pact_path}/pact-http-server/src/test/resources/contracts/fraud/shouldMarkClientAsFraud.json[indent=0]
----

====== Pact for producers

On the producer side you have add to your plugin configuration two additional dependencies.
One is the Spring Cloud Contract Pact support and the other represents the current
Pact version that you're using.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{standalone_pact_path}/pact-http-server/pom.xml[tags=pact_dependency,indent=0]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{standalone_pact_path}/pact-http-server/build.gradle[tags=pact_dependency,indent=0]
----

When you execute the build of your application a test, looking more or less like this, will be generated

[source,java,indent=0]
----
	@Test
	public void validate_shouldMarkClientAsFraud() throws Exception {
		// given:
			MockMvcRequestSpecification request = given()
					.header("Content-Type", "application/vnd.fraud.v1+json")
					.body("{\"clientId\":\"1234567890\",\"loanAmount\":99999}");

		// when:
			ResponseOptions response = given().spec(request)
					.put("/fraudcheck");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
			assertThat(response.header("Content-Type")).isEqualTo("application/vnd.fraud.v1+json;charset=UTF-8");
		// and:
			DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
			assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
		// and:
			assertThat(parsedJson.read("$.fraudCheckStatus", String.class)).matches("FRAUD");
	}
----

and the stub looking like this

[source,javascript,indent=0]
----
{
  "uuid" : "996ae5ae-6834-4db6-8fac-358ca187ab62",
  "request" : {
    "url" : "/fraudcheck",
    "method" : "PUT",
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/vnd.fraud.v1+json"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.loanAmount == 99999)]"
    }, {
      "matchesJsonPath" : "$[?(@.clientId =~ /([0-9]{10})/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"fraudCheckStatus\":\"FRAUD\",\"rejectionReason\":\"Amount too high\"}",
    "headers" : {
      "Content-Type" : "application/vnd.fraud.v1+json;charset=UTF-8"
    }
  }
}
----

====== Pact for consumers

On the producer side you have add to your project dependencies two additional dependencies.
One is the Spring Cloud Contract Pact support and the other represents the current
Pact version that you're using.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
include::{standalone_pact_path}/pact-http-client/pom.xml[tags=pact_dependency,indent=0]
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
include::{standalone_pact_path}/pact-http-client/build.gradle[tags=pact_dependency,indent=0]
----

====== RAML converter

WARNING: RAML support is experimental and prone to changes in the future. Also it requires
 certain conditions on the RAML contract to make the conversion work properly

Spring Cloud Contract comes with an experimental out of the box support for https://raml.org/[RAML] representation of contracts.
In other words instead of using the Groovy DSL you can use Pact files. In this section
we will present how to add such a support for your project.

====== RAML constraints

The biggest challenge in making RAML become an input for Spring Cloud Contract is that RAML is
an extended representation of a schema. It allows you to group a few request examples together
with some response examples. Spring Cloud Contract doesn't want to bind to a schema thus it
focuses on presenting a pair of request response examples. That's why not every RAML
file is possible to be converted into a Spring Cloud Contract example. Of course with time
and feedback from the users we will try to minimize the number of constraints.

For the RAML contract be considered proper as input for Spring Cloud Contract it has to
pass the following tests:

- It has to use RAML version 1.0
- The *baseUri* if present has to contain only the host and no additional path (e.g. *http://localhost:8081* is ok, whereas *http://localhost:8081/api/2.5* is not)
- Every request that has a body has to have an *example* of a body
- Every request that has headers has to have *default values* for these headers
- Every request that has query parameters has to have *default values* for these parameters
- Every response that has a body has to have an *example* of a body
- Every response that has headers has to have *default values* for these headers

If you have multiple examples of of bodies only the first one will be taken into consideration.
The best solution is to have a single pair of request / response in a single RAML file.

====== RAML example

We will be working on the following example of a RAML contract. We've placed this file under
the `src/test/resources/contracts` folder.

[source,yml,indent=0]
----
include::{raml_spec_path}/src/test/resources/api.raml[indent=0]
----

====== RAML for producers

On the producer side you have add to your project dependencies a couple of dependencies.
The Spring Cloud Contract RAML support and RAML related dependencies to your Spring Cloud Contract
Maven plugin / Gradle buildscript classpath:

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-spec-raml</artifactId>
    <version>${spring-cloud-contract.version}</version>
</dependency>
<dependency>
    <groupId>org.raml</groupId>
    <artifactId>raml-parser-2</artifactId>
    <version>1.0.6</version>
</dependency>
<dependency>
    <groupId>org.raml</groupId>
    <artifactId>com.mulesoft.jaxrs.raml.generator</artifactId>
    <version>1.3.4</version>
</dependency>
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
classpath "org.springframework.cloud:spring-cloud-contract-spec-raml:${verifierVersion}"
classpath 'org.raml:raml-parser-2:1.0.6'
classpath 'org.raml:com.mulesoft.jaxrs.raml.generator:1.3.4'
----

====== RAML for consumers

On the producer side you need to add the following dependencies to your test compile
classpath.

[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-spec-raml</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.raml</groupId>
    <artifactId>raml-parser-2</artifactId>
    <version>1.0.6</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.raml</groupId>
    <artifactId>com.mulesoft.jaxrs.raml.generator</artifactId>
    <version>1.3.4</version>
    <scope>test</scope>
</dependency>
----

[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
testCompile "org.springframework.cloud:spring-cloud-contract-spec-raml:${verifierVersion}"
testCompile 'org.raml:raml-parser-2:1.0.6'
testCompile 'org.raml:com.mulesoft.jaxrs.raml.generator:1.3.4'
----

==== Custom test generator

If you want to generate tests for different languages than Java or you're
not happy with the way we're building Java tests for you then you can register
your own implementation to do that.

Thanks to the interface

[source,groovy]
----
include::{verifier_core_path}/src/main/groovy/org/springframework/cloud/contract/verifier/builder/SingleTestGenerator.groovy[indent=0,lines=17..-1]
----

you can register your own implementation that generates a test. Again, it's enough to provide
a proper `spring.factories` file. Example:

[source]
----
org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator
----

==== Custom stub generator

If you want to generate stubs for other stub server than WireMock it's enough to
 plug in your own implementation of this interface:

[source,groovy]
----
include::{converters_path}/src/main/groovy/org/springframework/cloud/contract/verifier/converter/StubGenerator.groovy[indent=0,lines=16..-1]
----

you can register your own implementation that generate Stubs. Again, it's enough to provide
a proper `spring.factories` file. Example:

[source]
----
include::{converters_path}/src/main/resources/META-INF/spring.factories[indent=0]
----

The default implementation is the WireMock stub generation.

TIP: You can provide multiple stub generator implementations. That way for example from a single
DSL as input you can e.g. produce WireMock stubs and Pact files too!

==== Custom Stub Runner

If you decide to have a custom stub generation you also need a custom way of running
stubs with your different stub provider.

Let us assume that you're using https://github.com/dreamhead/moco[Moco] to build your stubs.
You wrote a proper stub generator and your stubs got placed in a JAR file.

In order for Stub Runner to know how to run your stubs you have to define a custom
 HTTP Stub server implementation. It can look like this:

[source,groovy]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/groovy/org/springframework/cloud/contract/stubrunner/provider/moco/MocoHttpServerStub.groovy[indent=0,lines=16..-1]
----

and just register it in your `spring.factories` file

[source]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/resources/META-INF/spring.factories[indent=0,lines=1..4]
----

that way you'll be able to run stubs using Moco.

IMPORTANT: If you don't provide any implementation then the default one - WireMock based
will be picked. If you provide more than one then the first one on the list will be picked.

==== Custom Stub Downloader

You can customize the way your stubs are downloaded. If you don't want to download the JARs
from Nexus / Artifactory in the way we do by default you can set your own implementation.
Below you can find an example of a Stub Downloader Provider that takes `json` files from the test resources
from classpath, copies them to a temp file and then passes that temporary folder
 as a root for the stubs.

[source,java]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/groovy/org/springframework/cloud/contract/stubrunner/provider/moco/ClasspathStubProvider.groovy[indent=0,lines=16..-1]
----

and just register it in your `spring.factories` file

[source]
----
include::{tests_path}/spring-cloud-contract-stub-runner-moco/src/test/resources/META-INF/spring.factories[indent=0,lines=5..-1]
----

that way you'll be able to pick a folder with the source of your stubs.

IMPORTANT: If you don't provide any implementation then the default one - Aether based that will download stubs from a remote repo
will be picked. If you provide more than one then the first one on the list will be picked.
